#autoload

# Widget management and ZLE integration helpers for zskk.

# Initialize widget bookkeeping structures.
function zskk::widgets-init {
  emulate -L zsh

  typeset -gA ZSKK_WIDGET_ORIGINAL
  typeset -gA ZSKK_WIDGET_METADATA
  typeset -g ZSKK_WIDGET_LAST_MESSAGE=""

  if ! typeset -p ZSKK_BINDINGS &>/dev/null || (( ${#ZSKK_BINDINGS[@]:-0} == 0 )); then
    if (( ${+functions[zskk::config-load-bindings]} )); then
      zskk::config-load-bindings
    else
      typeset -gA ZSKK_BINDINGS
      ZSKK_BINDINGS=(
        convert-next $' '
        convert-prev '^K'
        convert-commit '^J'
        convert-cancel '^G'
        toggle-mode '^]'
      )
      local action
      for action in ${(k)ZSKK_BINDINGS}; do
        ZSKK_BINDINGS[${action}]=${ZSKK_BINDINGS[${action}]}
      done
    fi
  fi

  ZSKK_WIDGET_ORIGINAL=()
  ZSKK_WIDGET_METADATA=()
}

# Remember the original widget name before overriding it.
function zskk::widgets-register-original {
  emulate -L zsh

  local logical=$1
  local original=$2
  [[ -z ${logical} || -z ${original} ]] && return 1
  ZSKK_WIDGET_ORIGINAL[${logical}]=${original}
}

# Call the original widget implementation if available.
function zskk::widgets-call-original {
  emulate -L zsh

  local logical=$1
  shift
  local original=${ZSKK_WIDGET_ORIGINAL[${logical}]:-}
  [[ -z ${original} ]] && return 1

  if zle -la | grep -Fxq -- "${original}"; then
    zle ${original} -- "$@"
    return $?
  fi
  return 1
}

function zskk::widgets-bindkey {
  emulate -L zsh

  local keymap=$1
  local key=$2
  local widget=$3
  [[ -z ${key} ]] && return 1

  local original='__zskk-unbound__'

  local current
  if current=$(bindkey -M "${keymap}" "${key}" 2>/dev/null); then
    original=${current##* }
  fi

  bindkey -M "${keymap}" "${key}" "${widget}"
  ZSKK_BOUND_WIDGETS+=("binding:${keymap}:${key}:${original}")
}

function zskk::widgets-binding-keys {
  emulate -L zsh

  local action=$1
  typeset -ga reply
  reply=()

  if ! typeset -p ZSKK_BINDINGS &>/dev/null; then
    return 1
  fi

  local value=${ZSKK_BINDINGS[${action}]:-}
  [[ -z ${value} ]] && return 1

  reply=(${(ps:\n:)value})
  return 0
}

function zskk::widgets-trim-preedit {
  emulate -L zsh

  local suffix=$1
  local current=${ZSKK_STATE[preedit]:-}
  [[ -z ${suffix} || -z ${current} ]] && return 0

  local -a chars=(${(s::)current})
  local -a remove=(${(s::)suffix})
  local total=${#chars}
  local cut=${#remove}
  if (( cut >= total )); then
    ZSKK_STATE[preedit]=""
  else
    local end=$(( total - cut ))
    ZSKK_STATE[preedit]=${(j::)chars[1,end]}
  fi
}

function zskk::widgets-append-okuri {
  emulate -L zsh

  local text=$1
  [[ -z ${text} ]] && return 0

  local okuri=${ZSKK_STATE[okuri]:-}
  okuri+=${text}
  ZSKK_STATE[okuri]=${okuri}
  ZSKK_STATE[okuri_mode]=1
}

function zskk::widgets-pop-okuri {
  emulate -L zsh

  local okuri=${ZSKK_STATE[okuri]:-}
  [[ -z ${okuri} ]] && { REPLY=""; return 1; }

  local -a chars=(${(s::)okuri})
  local removed=${chars[-1]}
  local length=${#chars}
  if (( length <= 1 )); then
    ZSKK_STATE[okuri]=""
  else
    local end=$(( length - 1 ))
    ZSKK_STATE[okuri]=${(j::)chars[1,end]}
  fi

  if [[ -z ${ZSKK_STATE[okuri]:-} ]]; then
    ZSKK_STATE[okuri_mode]=0
  fi

  REPLY=${removed}
  return 0
}

# Determine whether conversion candidate selection is active.
function zskk::widgets-conversion-active {
  emulate -L zsh
  (( ${ZSKK_STATE[candidate_count]:-0} > 0 )) && return 0
  return 1
}

# Helper: build status message for current pre-edit state.
function zskk::widgets-build-status {
  emulate -L zsh

  local mode=${ZSKK_STATE[mode]:-direct}
  local pre=${ZSKK_STATE[preedit]:-}
  local composing=${ZSKK_STATE[composing]:-}
  local okuri=${ZSKK_STATE[okuri]:-}

  if (( ${ZSKK_STATE[candidate_count]:-0} > 0 )); then
    REPLY="${mode}:候補(${ZSKK_STATE[current_candidate]:-})"
    return 0
  fi

  local display="${pre}${composing}${okuri}"
  if [[ -z ${display} ]]; then
    REPLY=""
    return 1
  fi

  REPLY="${mode}:${display}"
  return 0
}

# Update status message both for UI and test inspection.
function zskk::widgets-update-status {
  emulate -L zsh

  local message=""
  if zskk::widgets-build-status; then
    message=${REPLY}
  fi

  ZSKK_WIDGET_LAST_MESSAGE=${message}

  if [[ -n ${message} ]]; then
    zle -M -- "${message}"
  else
    zle -M -- ""
  fi
}

# Remove suffix text from LBUFFER if present.
function zskk::widgets-remove-suffix {
  emulate -L zsh

  local text=$1
  local len=${#text}
  (( len == 0 )) && return 0

  local buf=${LBUFFER:-}
  local total=${#buf}
  if (( len >= total )); then
    LBUFFER=""
  else
    LBUFFER=${buf[1,${total}-len]}
  fi
}

# Flush composing buffer into LBUFFER (used prior to conversion).
function zskk::widgets-flush-composing {
  emulate -L zsh

  local composing=${ZSKK_STATE[composing]:-}
  if [[ -z ${composing} ]]; then
    REPLY=""
    return 1
  fi

  zskk::input-flush "${ZSKK_STATE[mode]:-hiragana}"
  local produced=${REPLY}
  if [[ -n ${produced} ]]; then
    if (( ${ZSKK_STATE[okuri_mode]:-0} )); then
      zskk::widgets-trim-preedit "${produced}"
      zskk::widgets-append-okuri "${produced}"
    fi
    LBUFFER+="${produced}"
  fi
  return 0
}

# Start conversion for the current pre-edit string.
function zskk::widgets-start-conversion {
  emulate -L zsh

  if zskk::widgets-conversion-active; then
    return 1
  fi

  zskk::widgets-flush-composing

  local reading=${ZSKK_STATE[preedit]:-}
  local okuri=${ZSKK_STATE[okuri]:-}
  if [[ -z ${reading} ]]; then
    return 1
  fi

  if [[ -n ${okuri} ]]; then
    zskk::widgets-remove-suffix "${okuri}"
  fi
  zskk::widgets-remove-suffix "${reading}"

  if ! zskk::conversion-begin "${reading}" "${okuri}"; then
    local fallback=${REPLY}
    LBUFFER+="${fallback}"
    ZSKK_STATE[okuri]=${okuri}
    ZSKK_STATE[okuri_mode]=$(( ${#okuri} > 0 ))
    zskk::widgets-update-status
    return 0
  fi

  local candidate=${REPLY}
  LBUFFER+="${candidate}"
  zskk::widgets-update-status
  return 0
}

# Advance to next candidate.
function zskk::widgets-cycle-next {
  emulate -L zsh

  if ! zskk::widgets-conversion-active; then
    return 1
  fi

  local current=${ZSKK_STATE[current_candidate]:-}
  zskk::widgets-remove-suffix "${current}"
  zskk::conversion-next
  local candidate=${REPLY}
  LBUFFER+="${candidate}"
  zskk::widgets-update-status
  return 0
}

# Step back to previous candidate.
function zskk::widgets-cycle-prev {
  emulate -L zsh

  if ! zskk::widgets-conversion-active; then
    return 1
  fi

  local current=${ZSKK_STATE[current_candidate]:-}
  zskk::widgets-remove-suffix "${current}"
  zskk::conversion-prev
  local candidate=${REPLY}
  LBUFFER+="${candidate}"
  zskk::widgets-update-status
  return 0
}

# Commit current candidate and reset conversion state.
function zskk::widgets-commit {
  emulate -L zsh

  if ! zskk::widgets-conversion-active; then
    return 1
  fi

  zskk::conversion-commit
  zskk::widgets-update-status
  return 0
}

# Cancel conversion and restore original reading.
function zskk::widgets-cancel {
  emulate -L zsh

  if ! zskk::widgets-conversion-active; then
    return 1
  fi

  local current=${ZSKK_STATE[current_candidate]:-}
  zskk::widgets-remove-suffix "${current}"
  zskk::conversion-cancel
  local restored=${REPLY}
  if [[ -n ${restored} ]]; then
    LBUFFER+="${restored}"
  fi
  zskk::widgets-update-status
  return 0
}

# Pure handler used by widget wrappers to process printable input.
function zskk::widgets-handle-insert {
  emulate -L zsh -o extended_glob

  local char=$1
  local mode=${ZSKK_STATE[mode]:-hiragana}

  if [[ -z ${char} ]]; then
    REPLY=""
    return 1
  fi

  if (( ${ZSKK_STATE[candidate_count]:-0} > 0 )); then
    zskk::widgets-commit
  fi

  if [[ ${mode} == direct ]]; then
    REPLY="${char}"
    return 1
  fi

  local is_alpha=0
  [[ ${char} == [a-zA-Z] ]] && is_alpha=1

  local okuri_char=0
  local feed_char=${char}

  if [[ ${char} == [A-Z] ]]; then
    feed_char=${char:l}
    ZSKK_STATE[okuri_mode]=1
    okuri_char=1
  elif (( ${ZSKK_STATE[okuri_mode]:-0} )) && [[ ${char} == [a-z] ]]; then
    okuri_char=1
  elif ! (( is_alpha )); then
    if (( ${ZSKK_STATE[okuri_mode]:-0} )); then
      ZSKK_STATE[okuri_mode]=0
    fi
  fi

  zskk::input-feed "${mode}" "${feed_char:l}"
  local committed=${REPLY}

  if (( okuri_char )) && [[ -n ${committed} ]]; then
    zskk::widgets-trim-preedit "${committed}"
    zskk::widgets-append-okuri "${committed}"
  fi

  if [[ -n ${committed} ]]; then
    LBUFFER+="${committed}"
  fi

  zskk::widgets-update-status
  REPLY=${committed}
  return 0
}

# Handle backspace and keep zskk state consistent.
function zskk::widgets-handle-backspace {
  emulate -L zsh

  if (( ${ZSKK_STATE[candidate_count]:-0} > 0 )); then
    zskk::widgets-cancel
    return 0
  fi

  local composing=${ZSKK_STATE[composing]:-}
  if [[ -n ${composing} ]]; then
    ZSKK_STATE[composing]=${composing[1,${#composing}-1]}
    zskk::widgets-update-status
    return 0
  fi

  local okuri=${ZSKK_STATE[okuri]:-}
  if [[ -n ${okuri} ]]; then
    if zskk::widgets-pop-okuri; then
      zskk::widgets-remove-suffix "${REPLY}"
    fi
    zskk::widgets-update-status
    return 0
  fi

  local pre=${ZSKK_STATE[preedit]:-}
  if [[ -n ${pre} ]]; then
    local -a chars=(${(s::)pre})
    local removed=${chars[-1]}
    zskk::widgets-remove-suffix "${removed}"
    local plen=${#chars}
    if (( plen <= 1 )); then
      ZSKK_STATE[preedit]=""
    else
      local end=$(( plen - 1 ))
      ZSKK_STATE[preedit]=${(j::)chars[1,end]}
    fi
    zskk::widgets-update-status
    return 0
  fi

  return 1
}

# Toggle between direct and hiragana mode (temporary helper).
function zskk::widgets-toggle-mode {
  emulate -L zsh

  if (( ${ZSKK_STATE[candidate_count]:-0} > 0 )); then
    zskk::conversion-commit
  fi

  local current=${ZSKK_STATE[mode]:-direct}
  if [[ ${current} == direct ]]; then
    ZSKK_STATE[mode]=hiragana
  else
    ZSKK_STATE[mode]=direct
    zskk::conversion-reset
    zskk::input-reset
  fi
  zskk::widgets-update-status
  return 0
}

# ZLE widget: intercepted self-insert.
function zskk::widget-self-insert {
  emulate -L zsh -o extended_glob

  local char=${KEYS:-}
  if ! zskk::widgets-handle-insert "${char}"; then
    zskk::widgets-call-original self-insert "$@"
  fi
}

# ZLE widget: backward delete.
function zskk::widget-backspace {
  emulate -L zsh

  if zskk::widgets-handle-backspace; then
    return
  fi

  if zskk::widgets-call-original backward-delete-char "$@"; then
    return
  fi
}

# ZLE widget: toggle mode hotkey.
function zskk::widget-toggle-mode {
  emulate -L zsh
  zskk::widgets-toggle-mode
}

# ZLE widget: space / next candidate.
function zskk::widget-convert-next {
  emulate -L zsh

  if [[ ${ZSKK_STATE[mode]:-direct} == direct ]]; then
    zskk::widgets-call-original self-insert "$@"
    return
  fi

  if zskk::widgets-conversion-active; then
    zskk::widgets-cycle-next
  else
    if ! zskk::widgets-start-conversion; then
      zskk::widgets-call-original self-insert "$@"
    fi
  fi
}

# ZLE widget: previous candidate.
function zskk::widget-convert-prev {
  emulate -L zsh

  if [[ ${ZSKK_STATE[mode]:-direct} == direct ]]; then
    return
  fi

  if zskk::widgets-conversion-active; then
    zskk::widgets-cycle-prev
  else
    if ! zskk::widgets-start-conversion; then
      return
    fi
  fi
}

# ZLE widget: commit current candidate (Ctrl-J).
function zskk::widget-convert-commit {
  emulate -L zsh

  if zskk::widgets-commit; then
    zskk::widgets-call-original self-insert "$@"
  fi
}

# ZLE widget: cancel conversion (Ctrl-G).
function zskk::widget-convert-cancel {
  emulate -L zsh

  if zskk::widgets-cancel; then
    return
  fi
}

# ZLE widget: accept line, ensuring pending state is flushed.
function zskk::widget-accept-line {
  emulate -L zsh

  if (( ${ZSKK_STATE[candidate_count]:-0} > 0 )); then
    zskk::widgets-commit
  else
    zskk::widgets-flush-composing
    zskk::conversion-reset
  fi
  zskk::input-reset
  zskk::widgets-update-status

  zskk::widgets-call-original accept-line "$@"
}

