#autoload

# zskk-init -- initialize plugin state, configuration, and widget placeholders.
function zskk-init {
  emulate -L zsh -o extended_glob

  if [[ -n ${_ZSKK_INITIALIZED:-} ]]; then
    return 0
  fi
  typeset -g _ZSKK_INITIALIZED=1

  local plugin_root=${ZSKK_PLUGIN_ROOT:-${${(%):-%x}:A:h:h}}
  typeset -g ZSKK_PLUGIN_ROOT=${plugin_root}

  local module
  local -a modules=(
    zskk-dict
    zskk-input
    zskk-engine
    zskk-widgets
  )
  for module in ${modules}; do
    local path=${plugin_root}/functions/${module}
    if [[ -r ${path} ]]; then
      source ${path}
    fi
  done

  zskk::load-config "$@"
  zskk::prepare-state
  if ! zskk::dict-init; then
    print -u2 -- "zskk: warning: dictionary initialization failed"
  fi
  zskk::input-init
  zskk::engine-init
  zskk::widgets-init
  zskk::install-widgets
}

# Load plugin configuration from zstyle and environment variables.
function zskk::load-config {
  emulate -L zsh

  typeset -gA ZSKK_CONFIG

  local value sample_dict
  sample_dict=${ZSKK_PLUGIN_ROOT:-${${(%):-%N}:A:h}}/jisyo/SKK-JISYO.sample

  if zstyle -s ':zskk:dict' system value; then
    ZSKK_CONFIG[dict_path]="${value}"
  elif zstyle -s ':zskk:dict' path value; then
    ZSKK_CONFIG[dict_path]="${value}"
  elif [[ -n ${ZSKK_DICT_PATH:-} ]]; then
    ZSKK_CONFIG[dict_path]="${ZSKK_DICT_PATH}"
  else
    ZSKK_CONFIG[dict_path]="${sample_dict}"
  fi

  if zstyle -s ':zskk:dict' personal value; then
    ZSKK_CONFIG[personal_dict]="${value}"
  elif [[ -n ${ZSKK_PERSONAL_DICT:-} ]]; then
    ZSKK_CONFIG[personal_dict]="${ZSKK_PERSONAL_DICT}"
  else
    ZSKK_CONFIG[personal_dict]="${HOME}/.zskk-jisyo"
  fi

  if zstyle -s ':zskk:init' mode value; then
    ZSKK_CONFIG[initial_mode]="${value}"
  else
    ZSKK_CONFIG[initial_mode]="hiragana"
  fi

  if zstyle -s ':zskk:keymap' map value; then
    ZSKK_CONFIG[keymap]="${value}"
  else
    ZSKK_CONFIG[keymap]="${${(M)KEYMAP:#(viins|main|emacs)}:-main}"
  fi
}

# Prepare top-level state containers. Detailed implementation comes later.
function zskk::prepare-state {
  emulate -L zsh

  typeset -gA ZSKK_STATE
  ZSKK_STATE=(
    mode "${ZSKK_CONFIG[initial_mode]}"
    composing ""
    preedit ""
    okuri ""
    candidates ""
    lookup_key ""
    candidate_count 0
    candidate_index -1
    current_candidate ""
    last_commit ""
  )

  typeset -gA ZSKK_CACHE
  ZSKK_CACHE=()
}

# Register widgets and bind keys used by zskk.
function zskk::install-widgets {
  emulate -L zsh

  typeset -ga ZSKK_BOUND_WIDGETS
  ZSKK_BOUND_WIDGETS=()

  local keymap="${ZSKK_CONFIG[keymap]}"

  local -A overrides=(
    self-insert zskk::widget-self-insert
    backward-delete-char zskk::widget-backspace
    accept-line zskk::widget-accept-line
  )

  local widget handler alias
  for widget handler in ${(kv)overrides}; do
    alias="zskk-orig-${widget}"
    if zle -A "${widget}" "${alias}" 2>/dev/null; then
      zskk::widgets-register-original "${widget}" "${alias}"
      ZSKK_BOUND_WIDGETS+=("override:${widget}:${alias}")
      zle -N "${widget}" "${handler}"
    fi
  done

  local -A custom=(
    zskk-toggle-mode zskk::widget-toggle-mode
    zskk-convert-next zskk::widget-convert-next
    zskk-convert-prev zskk::widget-convert-prev
    zskk-convert-commit zskk::widget-convert-commit
    zskk-convert-cancel zskk::widget-convert-cancel
  )

  local name function_name
  for name function_name in ${(kv)custom}; do
    zle -N "${name}" "${function_name}"
    ZSKK_BOUND_WIDGETS+=("custom:${name}")
  done

  zskk::widgets-update-status

  zskk::widgets-bindkey "${keymap}" ' ' zskk-convert-next
  zskk::widgets-bindkey "${keymap}" '^J' zskk-convert-commit
  zskk::widgets-bindkey "${keymap}" '^G' zskk-convert-cancel
  zskk::widgets-bindkey "${keymap}" '^]' zskk-toggle-mode
}
