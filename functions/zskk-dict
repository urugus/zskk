#autoload

# zskk::dict-init -- load SKK dictionary sources based on configuration.
function zskk::dict-init {
  emulate -L zsh -o extended_glob

  if [[ -n ${_ZSKK_DICT_READY:-} ]]; then
    return 0
  fi

  typeset -gA ZSKK_DICT
  typeset -gA ZSKK_DICT_STATS
  ZSKK_DICT=()
  ZSKK_DICT_STATS=(
    sources ""
    entries 0
  )

  local -a sources
  local main_path=${ZSKK_CONFIG[dict_path]:-}
  if [[ -n ${main_path} && -r ${main_path} ]]; then
    sources+=("${main_path}")
  fi

  local personal=${ZSKK_CONFIG[personal_dict]:-}
  if [[ -n ${personal} && -r ${personal} ]]; then
    sources+=("${personal}")
  fi

  if (( ${#sources} == 0 )); then
    local fallback_root=${ZSKK_PLUGIN_ROOT:-${${(%):-%N}:A:h}}
    local sample=${fallback_root}/jisyo/SKK-JISYO.sample
    if [[ -r ${sample} ]]; then
      if [[ -n ${main_path} ]]; then
        print -u2 -- "zskk: dictionary '${main_path}' not found; using bundled sample"
      else
        print -u2 -- "zskk: using bundled sample dictionary"
      fi
      sources+=("${sample}")
    else
      print -u2 -- "zskk: no readable dictionary sources"
      return 1
    fi
  fi

  local src count total=0
  for src in "${sources[@]}"; do
    if zskk::dict-load-file "${src}"; then
      count=${REPLY:-0}
      total=$(( total + count ))
    else
      print -u2 -- "zskk: failed loading dictionary ${src}"
    fi
  done

  ZSKK_DICT_STATS[sources]="${(j:, :)sources}"
  ZSKK_DICT_STATS[entries]=${total}
  typeset -g _ZSKK_DICT_READY=1
}

# zskk::dict-load-file -- read a single SKK dictionary file.
# Stores the number of parsed entries in REPLY.
function zskk::dict-load-file {
  emulate -L zsh -o extended_glob

  local path=$1
  local count=0

  if [[ -z ${path} || ! -r ${path} ]]; then
    REPLY=0
    return 1
  fi

  local line
  while IFS= read -r line || [[ -n ${line} ]]; do
    line=${line%$'\r'}
    if zskk::dict-parse-line "${line}"; then
      (( count++ ))
    fi
  done < "${path}"

  ZSKK_DICT_STATS["file:${path}"]=${count}
  REPLY=${count}
  return 0
}

# zskk::dict-parse-line -- parse a single SKK dictionary entry.
# Returns success (0) if an entry was recorded.
function zskk::dict-parse-line {
  emulate -L zsh -o extended_glob

  local line=$1
  [[ -z ${line//[[:space:]]/} ]] && return 1
  [[ ${line} == \;* ]] && return 1

  local key=${line%%[[:space:]]*}
  local rest=${line#${key}}
  rest=${rest##[[:space:]]}

  if [[ -z ${key} || -z ${rest} || ${rest} != /* ]]; then
    return 1
  fi

  local fragment=${rest}
  local candidate
  local -a candlist=()
  while [[ ${fragment} == /* ]]; do
    fragment=${fragment#/}
    candidate=${fragment%%/*}
    if [[ -z ${candidate} ]]; then
      break
    fi
    candlist+=("${candidate}")
    fragment=${fragment#${candidate}}
  done

  (( ${#candlist} )) || return 1

  local joined=${(j:$'\n':)candlist}
  local current=${ZSKK_DICT[${key}]:-}
  if [[ -n ${current} ]]; then
    ZSKK_DICT[${key}]="${current}"$'\n'"${joined}"
  else
    ZSKK_DICT[${key}]="${joined}"
  fi

  return 0
}

# zskk::dict-get -- populate reply array with candidates for a given key.
function zskk::dict-get {
  emulate -L zsh -o extended_glob

  local key=$1
  if [[ -z ${key} || -z ${ZSKK_DICT[${key}]:-} ]]; then
    typeset -ga reply
    reply=()
    REPLY=""
    return 1
  fi

  typeset -ga reply
  reply=(${(@s:$'\n':)ZSKK_DICT[${key}]})
  REPLY=${ZSKK_DICT[${key}]}
  return 0
}
